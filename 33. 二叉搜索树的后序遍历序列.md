# [äºŒå‰æœç´¢æ ‘çš„ååºéå†åºåˆ—](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=11176&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## é¢˜ç›®æè¿°

è¾“å…¥ä¸€ä¸ªæ•´æ•°æ•°ç»„ï¼Œåˆ¤æ–­è¯¥æ•°ç»„æ˜¯ä¸æ˜¯æŸäºŒå‰æœç´¢æ ‘çš„ååºéå†çš„ç»“æœã€‚å¦‚æœæ˜¯åˆ™è¾“å‡ºYes,å¦åˆ™è¾“å‡ºNoã€‚å‡è®¾è¾“å…¥çš„æ•°ç»„çš„ä»»æ„ä¸¤ä¸ªæ•°å­—éƒ½äº’ä¸ç›¸åŒã€‚





ç”±äºäºŒå‰æœç´¢æ ‘çš„æ€§è´¨æ˜¯å·¦è¾¹å°å³è¾¹å¤§ï¼Œç„¶åé¢˜ç›®ç»™å‡ºçš„æ˜¯ååºéå†ï¼Œé‚£ä¹ˆæœ€åä¸€ä¸ªèŠ‚ç‚¹ä¸€å®šæ˜¯æ ¹èŠ‚ç‚¹ã€‚
æ¯”å¦‚è¯´ï¼š[1,3,2,6,5]ï¼Œè¿™ä¸ªåºåˆ—ä¸­5å°±æ˜¯æ ¹èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå¦‚ä½•åˆ¤æ–­è¿™æ˜¯ä¸æ˜¯ä¸€é¢—äºŒå‰æœç´¢æ ‘å‘¢ï¼Ÿ
ä»å·¦è‡³å³ï¼Œå¼€å§‹æ‰«ææ•°ç»„ï¼Œé‡åˆ°çš„ç¬¬ä¸€ä¸ªæ¯”5å¤§çš„èŠ‚ç‚¹ä¸€å®šæ˜¯è¿™ä¸ªæ ¹èŠ‚ç‚¹çš„å³å­æ ‘ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ã€‚è¿™ä¸ªæ•°ç»„ä¸­6å°±æ˜¯5çš„å³å­æ ‘èŠ‚ç‚¹ï¼Œå¦‚æœä»6å¼€å§‹ä¹‹åçš„èŠ‚ç‚¹æœ‰æ¯”5å°çš„æ•°ï¼Œé‚£ä¹ˆè¿™å°±ä¸€å®šä¸æ˜¯ä¸€é¢—äºŒå‰æœç´¢æ ‘ã€‚å› ä¸ºååºéå†ï¼Œå°±æ˜¯å·¦å³ä¸­ï¼Œè€Œä¸”è¿™åˆæ˜¯ä¸€é¢—äºŒå‰æœç´¢æ ‘ï¼Œå½“é‡åˆ°ç¬¬ä¸€ä¸ªæ¯”æ ¹èŠ‚ç‚¹å¤§çš„æ•°åŒ…æ‹¬ä¹‹åçš„æ•°å­—éƒ½æ˜¯å³å­æ ‘ã€‚
å¦‚æœåœ¨å³å­æ ‘ä¸­æ‰¾åˆ°ä¸€ä¸ªæ¯”æ ¹èŠ‚ç‚¹è¿˜å°çš„æ•°å­—ï¼Œå°±è¯æ˜è¿™ä¸æ˜¯ä¸€ä¸ªäºŒå‰æœç´¢æ ‘ã€‚

ä½œè€…ï¼šda-yu-co
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/xu-yao-zhi-dao-er-cha-sou-suo-shu-de-xin-37mk/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚





```c++
// BSæ ‘åç»­éå†  åç»­éå†æ—¶å·¦å³ç§ï¼Œåˆ¤å®šå¤±è´¥çš„æ¡ä»¶æ˜¯å³å­æ ‘ç§æœ‰æ¯”æ ¹ç»“ç‚¹å°çš„
// å› ä¸ºå¯ä»¥ä¸åœçš„é€’å½’


bool VerifySquenceOfBST(vector<int> sequence, int start, int end)//å‰é—­åå¼€
{
	//ä½¿ç”¨å‰é—­åå¼€çš„æ“ä½œ
	if (start + 1 >= end)
	{
		return true;
	}
	int rear = sequence[end-1 ];
	int front = sequence[start];
	int mid = start;                       æ³¨æ„æ‰¾ä¸ªåœ¨åŒºé—´å†…æ¯”æœ€åä¸€ä¸ªå¤§çš„å€¼ï¼Œè‹¥æ²¡æ‰¾åˆ°ï¼Œè¯´æ˜å‰é¢å…¨æ˜¯å·¦å­æ ‘ï¼Œåœ¨å–ä¸Šä¸€ä¸ª
	// for (int i = start; i < end; i++)
	// {
	// 	if (sequenece[i] > rear)
	// 	{
	// 		mid = i; //è¿™é‡Œmidæ˜¯å–åˆ°äº†çš„ï¼Œç›¸å½“äºæ˜¯å³å­æ ‘äº†
	// 		break;
	// 	}
	// }
	while(mid<end&&sequence[mid]<rear)mid++;

	for (int i = mid; i < end; i++)
	{
		if (sequence[i] < rear)
		{
			cout<<" i="<<i<<"sequence[i]=  "<<sequence[i]<<"   "<<rear<<endl;
			return false;
		}
	}
	return VerifySquenceOfBST(sequence, start, mid) && VerifySquenceOfBST(sequence, mid, end - 1); //è¿™ä¸ªå‡1æ˜¯å»æ‰æ ¹èŠ‚ç‚¹
}

bool VerifySquenceOfBST(vector<int> sequence)
{
	return VerifySquenceOfBST(sequence, 0, sequence.size());
}
```

è¿­ä»£æ–¹æ³•
è¿­ä»£æ–¹æ³•æ˜¯ä» è¿™ç¯‡é¢˜è§£ å­¦åˆ°çš„

æˆ‘ä»¬é€†åºéå†åºåˆ—ï¼Œè‹¥åºåˆ—æ˜¯äºŒå‰æœç´¢æ ‘çš„ååºéå†ï¼Œé‚£ä¹ˆåºåˆ—åº”è¯¥æ˜¯ å·¦å­æ ‘çš„ååºéå† | å³å­æ ‘çš„ååºéå† | æ ¹ç»“ç‚¹ è¿™æ ·çš„ï¼Œé€†åºéå†ä¼šå…ˆå¾—åˆ°æ ¹èŠ‚ç‚¹ï¼Œç„¶åéå†å³å­æ ‘ï¼Œæœ€åå†éå†å·¦å­æ ‘ã€‚

åœ¨éå†è¿‡ç¨‹ä¸­æˆ‘ä»¬å°†æ ¹èŠ‚ç‚¹å‹æ ˆï¼Œç„¶åéå†å³å­æ ‘ï¼Œè‹¥æ˜¯å³å­æ ‘å­˜åœ¨ï¼Œåˆ™åºåˆ—çš„ä¸‹ä¸€ä¸ªæ•°å°†å¤§äºæ ¹èŠ‚ç‚¹å¹¶ä¸”è¯¥ç»“ç‚¹å°±æ˜¯å³å­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼ŒåŒç†å‹å…¥æ ˆä¸­ï¼Œä»¥æ­¤ç±»æ¨ï¼Œç›´åˆ°åºåˆ—çš„ä¸‹ä¸€ä¸ªæ•°å°äºæ ¹ç»“ç‚¹äº†ï¼Œè¯´æ˜è¿™æ£µå­æ ‘æ²¡æœ‰å³å­æ ‘äº†ï¼Œä½†åºåˆ—çš„ä¸‹ä¸€ä¸ªæ•°å¹¶ä¸ä¸€å®šæ˜¯å½“å‰å­æ ‘æ ¹ç»“ç‚¹çš„å·¦å­©å­ç»“ç‚¹ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯å…¶çˆ¶èŠ‚ç‚¹æˆ–ç¥–çˆ¶ç»“ç‚¹çš„å·¦å­©å­ç»“ç‚¹ï¼Œæˆ‘ä»¬å¿…é¡»åœ¨ç¥–å…ˆç»“ç‚¹ä¸­æ‰¾åˆ°æ¯”åºåˆ—ä¸­ä¸‹ä¸€ä¸ªç»“ç‚¹å¤§çš„æœ€å°å€¼ä½œä¸ºåºåˆ—ä¸­ä¸‹ä¸€ä¸ªç»“ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼ˆè¿™é‡Œæœ‰ç‚¹éš¾ç†è§£ï¼Œéœ€ç»“åˆäºŒå‰æ ‘ å·¦<æ ¹<å³ çš„æ€§è´¨å’Œçˆ¶å­å…„å¼Ÿç»“ç‚¹çš„å¤§å°å…³ç³»æ€è€ƒä¸ºä»€ä¹ˆæ˜¯è¿™æ ·ï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†æ ˆä¸­ç»“ç‚¹ä¾æ¬¡å‡ºæ ˆï¼ˆå› ä¸ºæ ˆä¸­çš„æ˜¯å½“å‰ç»“ç‚¹çš„ä¸€ç³»åˆ—ç¥–å…ˆç»“ç‚¹ï¼‰ï¼Œç›´åˆ°æ ˆé¡¶ç»“ç‚¹å°äºåºåˆ—çš„ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œé‚£ä¹ˆæœ€åä¸€ä¸ªå‡ºæ ˆçš„å°±æ˜¯ç¥–å…ˆç»“ç‚¹ä¸­æ¯”åºåˆ—ä¸­ä¸‹ä¸€ä¸ªç»“ç‚¹å¤§çš„æœ€å°ç»“ç‚¹ï¼Œä¹Ÿå°±æ˜¯åºåˆ—ä¸­ä¸‹ä¸€ä¸ªç»“ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å†å°†åºåˆ—ä¸‹ä¸€ä¸ªç»“ç‚¹å…¥æ ˆï¼Œé‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œæœ€åå°±èƒ½æ ¹æ®ååºéå†å’ŒBSTçš„æ€§è´¨è¿˜åŸäºŒå‰æœç´¢æ ‘

\quad

ä¸¾ä¸ªğŸŒ°

[4, 8, 6, 12, 16, 14, 10]

10ä½œä¸ºæ ¹èŠ‚ç‚¹å…¥æ ˆï¼Œæ­¤æ—¶æ ˆï¼š[10]
14æ¯”æ ˆé¡¶å…ƒç´ 10å¤§ï¼Œè¯´æ˜æ˜¯10çš„å³å­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œå…¥æ ˆï¼Œæ­¤æ—¶æ ˆï¼š[10,14]
16æ¯”æ ˆé¡¶å…ƒç´ 14å¤§ï¼Œè¯´æ˜æ˜¯14çš„å³å­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œå…¥æ ˆï¼Œæ­¤æ—¶æ ˆï¼š[10,14,16]
12æ¯”æ ˆé¡¶å…ƒç´ 16å°ï¼Œè¯´æ˜æ ˆé¡¶å…ƒç´ 16æ²¡æœ‰å³å­æ ‘ï¼Œè¿™æ—¶æˆ‘ä»¬è¦å»æ ˆä¸­å¯»æ‰¾12çš„çˆ¶èŠ‚ç‚¹ï¼Œå³æ¯”12å¤§çš„æœ€å°ç¥–å…ˆç»“ç‚¹
16,14å‡æ¯”12å¤§ï¼Œä¾æ¬¡å‡ºæ ˆï¼Œæ­¤æ—¶æ ˆ'[10]`
æ ˆé¡¶å…ƒç´ æ¯”12å°ï¼Œé‚£ä¹ˆæœ€åå‡ºæ ˆçš„14å°±æ˜¯æ¯”12å¤§çš„æœ€å°ç¥–å…ˆç»“ç‚¹ï¼Œå³12çš„çˆ¶èŠ‚ç‚¹ï¼Œæ‰€ä»¥12æ˜¯14çš„å·¦å­©å­ç»“ç‚¹ï¼Œæœ€åå°†12å…¥æ ˆï¼Œæ­¤æ—¶æ ˆ[10,12]
6æ¯”æ ˆé¡¶å…ƒç´ 12å°ï¼Œè¯´æ˜æ ˆé¡¶å…ƒç´ 12æ²¡æœ‰å³å­æ ‘ï¼Œä¾æ¬¡å°†12,10å‡ºæ ˆï¼Œæ­¤æ—¶æ ˆç©ºï¼Œæ‰€ä»¥æœ€åå‡ºæ ˆçš„ç»“ç‚¹10å°±æ˜¯6çš„çˆ¶èŠ‚ç‚¹ï¼Œ6æ˜¯10çš„å·¦å­©å­ç»“ç‚¹ï¼Œæ­¤æ—¶æ ˆ [6]
8æ¯”æ ˆé¡¶å…ƒç´ 6å¤§ï¼Œè¯´æ˜æ˜¯6çš„å³å­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œå…¥æ ˆï¼Œæ­¤æ—¶æ ˆï¼š[6,8]
4æ¯”8ï¼Œ6å°ï¼Œä¾æ¬¡å‡ºæ ˆï¼Œ4æ˜¯æœ€åå‡ºæ ˆå…ƒç´ 6çš„å·¦å­©å­ç»“ç‚¹
åºåˆ—éå†ç»“æŸï¼Œæœ€åä¸€ä¸ªå€¼æ— éœ€å†å…¥æ ˆäº†ï¼Œå¾—åˆ°å¦‚ä¸‹äºŒå‰æœç´¢æ ‘

    10
   /  \
  6   14
 / \  / \
4  8 12  16
ç†è§£ä¸Šè¿°è¿˜åŸè¿‡ç¨‹ï¼Œé‚£ä¹ˆå¾ˆå®¹æ˜“å°±èƒ½å¾—åˆ°æ£€éªŒååºéå†çš„æ–¹æ³•ï¼Œä¸ºäº†ç®€åŒ–å¤„ç†è¾¹ç•Œæƒ…å†µï¼Œæˆ‘ä»¬å¢åŠ ä¸€ä¸ªè™šæ‹Ÿ

ä½œè€…ï¼šmeteordream
é“¾æ¥ï¼šhttps://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/bsthou-xu-jian-cha-di-gui-he-die-dai-jie-x1yo/
æ¥æºï¼šåŠ›æ‰£ï¼ˆLeetCodeï¼‰
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚

```java
class Solution {
public:
    bool VerifySquenceOfBST(vector<int> sequence) {
        return VerifySquenceOfBST(sequence, 0, sequence.size() - 1);
    }
    /* ååºéå†çš„æœ€åä¸€ä¸ªæ˜¯æ ¹ï¼Œé‚£ä¹ˆäºŒå‰æœç´¢æ ‘å·¦å­æ ‘éƒ½å°äºæ ¹ï¼Œå³å­æ ‘éƒ½å¤§äºæ ¹ */
    bool VerifySquenceOfBST(vector<int> sequence, int begin, int end) {
        if(sequence.empty() || begin > end)
            return false;
        
        int root = sequence[end];
        int i = begin;
        /* åœ¨å·¦å­æ ‘ä¸­æ‰¾åˆ°å¤§äºæ ¹çš„å€¼ï¼Œç„¶åå»å³å­æ ‘ */
        for(; i < end; ++i)
        {
            if(sequence[i] > root)
            {
                break;
            }
        }
        
        /* æ¥åˆ°å³å­æ ‘ï¼Œè‹¥éå†åˆ°å°äºæ ¹çš„ï¼Œé‚£ä¹ˆç›´æ¥è¿”å›false */
        for(int j = i; j < end; ++j)
        {
            if(sequence[j] < root)
            {
                return false;
            }
        }
        
        /* éå†å·¦å­æ ‘ */
        bool left = true;
        if(i > begin)
            left = VerifySquenceOfBST(sequence, begin, i - 1);
        
        /* éå†å³å­æ ‘ */
        bool right = true;
        if(i < end - 1)
            right = VerifySquenceOfBST(sequence, begin + i, end - 1);
        
        return left && right;
    }
};
```

```c++
#pragma once
#include "Node.h"
template<typename T>
class BStree
{
public:
	BStree(BSNode<T>* root=nullptr) { _root = root; }
	~BStree()
	{

	}
	void preOrder();
	void midOrder();
	void postOrder();
	void layerOrder();

	void insert(T key);	
	void remove(T key);
	void remove(BSNode<T>* node, T key);
	void destroy();
	void destroy(BSNode<T>* node);
	void print();

	BSNode<T>* prev(BSNode<T>* node);
	BSNode<T>* succ(BSNode<T>* node);

	BSNode<T>* search(T key);
	BSNode<T>* search(BSNode<T>* node,T key);
	BSNode<T>* find_min();
	BSNode<T>* find_min(BSNode<T>* node);
	BSNode<T>* find_max();
	BSNode<T>* find_max(BSNode<T>* node);



private:
	void preOrder(BSNode<T>* node);
	void midOrder(BSNode<T>* node);
	void postOrder(BSNode<T>* node);
	BSNode<T>* _root;
};

template<typename T>
inline void BStree<T>::preOrder()
{
	
	return preOrder(_root);
	
	
}

template<typename T>
inline void BStree<T>::midOrder()
{
	return midOrder(_root);
}

template<typename T>
inline void BStree<T>::postOrder()
{
	return postOrder(_root);
}

template<typename T>
inline void BStree<T>::insert(T key)
{
	//å…ˆæ‰¾åˆ°åœ¨å“ªä¸ªä½ç½®
	BSNode<T>* ptemp = new BSNode<T>(key);
	if (_root == nullptr)
	{
		_root = ptemp;
		return ;
	}
	BSNode<T>* p = _root;
	BSNode<T>* pre= nullptr;
	//ä¸‹é¢ä¸€é€šæ“ä½œå°±å¯ä»¥æ‰¾åˆ°è¦æ’å…¥é¢æœ€ä¸‹é¢çš„èŠ‚ç‚¹ï¼Œæ³¨æ„åˆ°è¿™å“¥èŠ‚ç‚¹ä¸å¯èƒ½æ˜¯æ‹¥æœ‰ä¸¤é¢—å­æ ‘çš„
	while (p!=nullptr)
	{
		pre = p;
		if (key > p->_value)
			p = p->_rchild;
		else if (key<p->_value)
		{
			p = p->_lchild;
		}
		else
		{
			std::cout << "å·²ç»å­˜åœ¨" << std::endl; 
				return;
		}
	}

	if (key > pre->_value)
	{
		pre->_rchild = ptemp;
	}
	else
	{
		pre->_lchild = ptemp;
	}
	ptemp->_parent = pre;
	return;
	


}

template<typename T>
inline void BStree<T>::remove(T key)
{
	return remove(_root, key);
}

template<typename T>
inline void BStree<T>::remove(BSNode<T>* pnode, T key)
{
	if(pnode!=nullptr)
	{ 
		if (key == pnode->_value)
		{
			BSNode<T>* pdel = nullptr;
			if (pnode->_lchild == nullptr && pnode->_rchild == nullptr)//æ ¹æ®ç§ç±»å…ˆè¦ç¡®å®šåˆ é™¤çš„æ˜¯é‚£ä¸ªå¶ç‰‡
			{
				pdel = pnode;
			}
			else
			{
				pdel = prev(pnode);
				T temp = pnode->_value;          //äº¤æ¢æ•°æ®
				pnode->_value = pdel->_value;
				pdel->_value = temp;

			}
			//å¯¹pdelåŠ ä»¥æ“ä½œ         pdelæœ€å¤šåªæœ‰ä¸€ä¸ªå­æ ‘
			BSNode<T>* pchild;
			if (pdel->_lchild)
			{
				pchild = pdel->_lchild;
			}
			else
			{
				pchild = pdel->_rchild;//åœ¨è¿™é‡Œä¸»ä¹‰æœ‰å¯èƒ½pchild ä¸ºnullptr;
			}
			if (pchild != nullptr)
			{
				if (pdel->_parent == nullptr)//å¦‚æœpdelæ˜¯æ ¹èŠ‚ç‚¹
				{
					_root = pchild;
				}
				pchild->_parent = pdel->_lchild;
			}
			if (pdel == pdel->_parent->_lchild)
			{
				pdel->_parent->_lchild = pchild;
			}
			else
			{
				pdel->_parent->_rchild = pchild;
			}

			delete pdel;
		}
		else if(key>pnode->_value)
		{
			remove(pnode->_rchild, key);
		}
		else
		{
			remove((pnode->_lchild, key));
		}
	}
	return;
}

template<typename T>
inline void BStree<T>::destroy()
{
	return destroy(_root);
}

template<typename T>
inline void BStree<T>::destroy(BSNode<T>* node)
{
	if (node != nullptr)
	{
		if (node->_lchild != nullptr)
		{
			destroy(node->_lchild);
		}
		if (node->_rchild != nullptr)
		{
			destroy(node->_rchild);
		}
		delete node;
		node = nullptr;
	}
}

template<typename T>
inline BSNode<T>* BStree<T>::prev(BSNode<T>* node)
{
	
	if (node->_lchild != nullptr)//å¦‚æœnodeæœ‰å·¦å­æ ‘ï¼Œæ‰¾å®ƒçš„å·¦å³å­æ ‘
	{
		BSNode<T>* pnode = node->_lchild;
		while (pnode->_rchild != nullptr)
		{
			pnode = pnode->_rchild;
		}
		return pnode;
	}
	else
	{
		//åšè¿‡ä¸å­˜åœ¨å·¦å­æ ‘
		while (node->_parent != nullptr && node->_parent->_lchild == node)
		{
			node = node->_parent;
		}
		return node->_parent;
	}
}

template<typename T>
inline BSNode<T>* BStree<T>::succ(BSNode<T>* node)
{
	if (node->_rchild != nullptr)
	{
		BSNode<T>* pnode = node->_rchild;
		while (pnode->_lchild!=nullptr)
		{
			pnode = pnode->_lchild;
		}
		return pnode;

	}
	else
	{
		while (node!=nullptr&&node->_parent->_rchild)
		{
			node = node->_parent;
		}
		return node->_parent;
	}
	return NULL;
}

template<typename T>
inline BSNode<T>* BStree<T>::search(T key)
{
	return search(_root,key);                  // è¿™å“¥nodeæ˜¯ç”¨æ¥è¡¨æ˜é‚£ä¸ªå¼€å§‹çš„ä½ç½®çš„ã€‚
}

template<typename T>
inline BSNode<T>* BStree<T>::search(BSNode<T>* node, T key)
{
	while(node!=nullptr)
	{ 
		if (key == node->_value)
		{
			return node;
		}
		else if(key>node->_value)
		{
			node = node->_rchild;
		}
		else
		{
			node = node->_lchild;
		}
	}
	return nullptr;
}

template<typename T>
inline BSNode<T>* BStree<T>::find_min()
{
	return find_min(_root);
}

template<typename T>
inline BSNode<T>* BStree<T>::find_min(BSNode<T>* node)
{
	while (node->_lchild != nullptr)
	{
		node = node->_lchild;
	}
	return node;
}

template<typename T>
inline BSNode<T>* BStree<T>::find_max()
{
	return find_max(_root);
}

template<typename T>
inline BSNode<T>* BStree<T>::find_max(BSNode<T>* node)
{
	while (node->_rchild!=nullptr)
	{
		node = node->_rchild;
	}
	return node;
}

template<typename T>
inline void BStree<T>::preOrder(BSNode<T>* node)
{
	BSNode<T>* pnode = node;
	if (pnode != nullptr)
	{
		std::cout << pnode->_value << std::endl;
		preOrder(pnode->_lchild);
		preOrder(pnode->_rchild);
	}
}

template<typename T>
inline void BStree<T>::midOrder(BSNode<T>* node)
{
	if (node != nullptr)
	{
		midOrder(node->_lchild);
		std::cout << node->_value << std::endl;
		midOrder(node->_rchild);
	}
}

```

