# [二叉搜索树的后序遍历序列](https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&tqId=11176&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。





由于二叉搜索树的性质是左边小右边大，然后题目给出的是后序遍历，那么最后一个节点一定是根节点。
比如说：[1,3,2,6,5]，这个序列中5就是根节点，那么如何判断这是不是一颗二叉搜索树呢？
从左至右，开始扫描数组，遇到的第一个比5大的节点一定是这个根节点的右子树中的一个节点。这个数组中6就是5的右子树节点，如果从6开始之后的节点有比5小的数，那么这就一定不是一颗二叉搜索树。因为后序遍历，就是左右中，而且这又是一颗二叉搜索树，当遇到第一个比根节点大的数包括之后的数字都是右子树。
如果在右子树中找到一个比根节点还小的数字，就证明这不是一个二叉搜索树。

作者：da-yu-co
链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/xu-yao-zhi-dao-er-cha-sou-suo-shu-de-xin-37mk/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





```c++
// BS树后续遍历  后续遍历时左右种，判定失败的条件是右子树种有比根结点小的
// 因为可以不停的递归


bool VerifySquenceOfBST(vector<int> sequence, int start, int end)//前闭后开
{
	//使用前闭后开的操作
	if (start + 1 >= end)
	{
		return true;
	}
	int rear = sequence[end-1 ];
	int front = sequence[start];
	int mid = start;                       注意找个在区间内比最后一个大的值，若没找到，说明前面全是左子树，在取上一个
	// for (int i = start; i < end; i++)
	// {
	// 	if (sequenece[i] > rear)
	// 	{
	// 		mid = i; //这里mid是取到了的，相当于是右子树了
	// 		break;
	// 	}
	// }
	while(mid<end&&sequence[mid]<rear)mid++;

	for (int i = mid; i < end; i++)
	{
		if (sequence[i] < rear)
		{
			cout<<" i="<<i<<"sequence[i]=  "<<sequence[i]<<"   "<<rear<<endl;
			return false;
		}
	}
	return VerifySquenceOfBST(sequence, start, mid) && VerifySquenceOfBST(sequence, mid, end - 1); //这个减1是去掉根节点
}

bool VerifySquenceOfBST(vector<int> sequence)
{
	return VerifySquenceOfBST(sequence, 0, sequence.size());
}
```

迭代方法
迭代方法是从 这篇题解 学到的

我们逆序遍历序列，若序列是二叉搜索树的后序遍历，那么序列应该是 左子树的后序遍历 | 右子树的后序遍历 | 根结点 这样的，逆序遍历会先得到根节点，然后遍历右子树，最后再遍历左子树。

在遍历过程中我们将根节点压栈，然后遍历右子树，若是右子树存在，则序列的下一个数将大于根节点并且该结点就是右子树的根节点，同理压入栈中，以此类推，直到序列的下一个数小于根结点了，说明这棵子树没有右子树了，但序列的下一个数并不一定是当前子树根结点的左孩子结点，也有可能是其父节点或祖父结点的左孩子结点，我们必须在祖先结点中找到比序列中下一个结点大的最小值作为序列中下一个结点的父节点（这里有点难理解，需结合二叉树 左<根<右 的性质和父子兄弟结点的大小关系思考为什么是这样），所以我们将栈中结点依次出栈（因为栈中的是当前结点的一系列祖先结点），直到栈顶结点小于序列的下一个结点，那么最后一个出栈的就是祖先结点中比序列中下一个结点大的最小结点，也就是序列中下一个结点的父节点，我们再将序列下一个结点入栈，重复上述过程，最后就能根据后序遍历和BST的性质还原二叉搜索树

\quad

举个🌰

[4, 8, 6, 12, 16, 14, 10]

10作为根节点入栈，此时栈：[10]
14比栈顶元素10大，说明是10的右子树的根节点，入栈，此时栈：[10,14]
16比栈顶元素14大，说明是14的右子树的根节点，入栈，此时栈：[10,14,16]
12比栈顶元素16小，说明栈顶元素16没有右子树，这时我们要去栈中寻找12的父节点，即比12大的最小祖先结点
16,14均比12大，依次出栈，此时栈'[10]`
栈顶元素比12小，那么最后出栈的14就是比12大的最小祖先结点，即12的父节点，所以12是14的左孩子结点，最后将12入栈，此时栈[10,12]
6比栈顶元素12小，说明栈顶元素12没有右子树，依次将12,10出栈，此时栈空，所以最后出栈的结点10就是6的父节点，6是10的左孩子结点，此时栈 [6]
8比栈顶元素6大，说明是6的右子树的根节点，入栈，此时栈：[6,8]
4比8，6小，依次出栈，4是最后出栈元素6的左孩子结点
序列遍历结束，最后一个值无需再入栈了，得到如下二叉搜索树

    10
   /  \
  6   14
 / \  / \
4  8 12  16
理解上述还原过程，那么很容易就能得到检验后序遍历的方法，为了简化处理边界情况，我们增加一个虚拟

作者：meteordream
链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/solution/bsthou-xu-jian-cha-di-gui-he-die-dai-jie-x1yo/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```java
class Solution {
public:
    bool VerifySquenceOfBST(vector<int> sequence) {
        return VerifySquenceOfBST(sequence, 0, sequence.size() - 1);
    }
    /* 后序遍历的最后一个是根，那么二叉搜索树左子树都小于根，右子树都大于根 */
    bool VerifySquenceOfBST(vector<int> sequence, int begin, int end) {
        if(sequence.empty() || begin > end)
            return false;
        
        int root = sequence[end];
        int i = begin;
        /* 在左子树中找到大于根的值，然后去右子树 */
        for(; i < end; ++i)
        {
            if(sequence[i] > root)
            {
                break;
            }
        }
        
        /* 来到右子树，若遍历到小于根的，那么直接返回false */
        for(int j = i; j < end; ++j)
        {
            if(sequence[j] < root)
            {
                return false;
            }
        }
        
        /* 遍历左子树 */
        bool left = true;
        if(i > begin)
            left = VerifySquenceOfBST(sequence, begin, i - 1);
        
        /* 遍历右子树 */
        bool right = true;
        if(i < end - 1)
            right = VerifySquenceOfBST(sequence, begin + i, end - 1);
        
        return left && right;
    }
};
```

```c++
#pragma once
#include "Node.h"
template<typename T>
class BStree
{
public:
	BStree(BSNode<T>* root=nullptr) { _root = root; }
	~BStree()
	{

	}
	void preOrder();
	void midOrder();
	void postOrder();
	void layerOrder();

	void insert(T key);	
	void remove(T key);
	void remove(BSNode<T>* node, T key);
	void destroy();
	void destroy(BSNode<T>* node);
	void print();

	BSNode<T>* prev(BSNode<T>* node);
	BSNode<T>* succ(BSNode<T>* node);

	BSNode<T>* search(T key);
	BSNode<T>* search(BSNode<T>* node,T key);
	BSNode<T>* find_min();
	BSNode<T>* find_min(BSNode<T>* node);
	BSNode<T>* find_max();
	BSNode<T>* find_max(BSNode<T>* node);



private:
	void preOrder(BSNode<T>* node);
	void midOrder(BSNode<T>* node);
	void postOrder(BSNode<T>* node);
	BSNode<T>* _root;
};

template<typename T>
inline void BStree<T>::preOrder()
{
	
	return preOrder(_root);
	
	
}

template<typename T>
inline void BStree<T>::midOrder()
{
	return midOrder(_root);
}

template<typename T>
inline void BStree<T>::postOrder()
{
	return postOrder(_root);
}

template<typename T>
inline void BStree<T>::insert(T key)
{
	//先找到在哪个位置
	BSNode<T>* ptemp = new BSNode<T>(key);
	if (_root == nullptr)
	{
		_root = ptemp;
		return ;
	}
	BSNode<T>* p = _root;
	BSNode<T>* pre= nullptr;
	//下面一通操作就可以找到要插入额最下面的节点，注意到这哥节点不可能是拥有两颗子树的
	while (p!=nullptr)
	{
		pre = p;
		if (key > p->_value)
			p = p->_rchild;
		else if (key<p->_value)
		{
			p = p->_lchild;
		}
		else
		{
			std::cout << "已经存在" << std::endl; 
				return;
		}
	}

	if (key > pre->_value)
	{
		pre->_rchild = ptemp;
	}
	else
	{
		pre->_lchild = ptemp;
	}
	ptemp->_parent = pre;
	return;
	


}

template<typename T>
inline void BStree<T>::remove(T key)
{
	return remove(_root, key);
}

template<typename T>
inline void BStree<T>::remove(BSNode<T>* pnode, T key)
{
	if(pnode!=nullptr)
	{ 
		if (key == pnode->_value)
		{
			BSNode<T>* pdel = nullptr;
			if (pnode->_lchild == nullptr && pnode->_rchild == nullptr)//根据种类先要确定删除的是那个叶片
			{
				pdel = pnode;
			}
			else
			{
				pdel = prev(pnode);
				T temp = pnode->_value;          //交换数据
				pnode->_value = pdel->_value;
				pdel->_value = temp;

			}
			//对pdel加以操作         pdel最多只有一个子树
			BSNode<T>* pchild;
			if (pdel->_lchild)
			{
				pchild = pdel->_lchild;
			}
			else
			{
				pchild = pdel->_rchild;//在这里主义有可能pchild 为nullptr;
			}
			if (pchild != nullptr)
			{
				if (pdel->_parent == nullptr)//如果pdel是根节点
				{
					_root = pchild;
				}
				pchild->_parent = pdel->_lchild;
			}
			if (pdel == pdel->_parent->_lchild)
			{
				pdel->_parent->_lchild = pchild;
			}
			else
			{
				pdel->_parent->_rchild = pchild;
			}

			delete pdel;
		}
		else if(key>pnode->_value)
		{
			remove(pnode->_rchild, key);
		}
		else
		{
			remove((pnode->_lchild, key));
		}
	}
	return;
}

template<typename T>
inline void BStree<T>::destroy()
{
	return destroy(_root);
}

template<typename T>
inline void BStree<T>::destroy(BSNode<T>* node)
{
	if (node != nullptr)
	{
		if (node->_lchild != nullptr)
		{
			destroy(node->_lchild);
		}
		if (node->_rchild != nullptr)
		{
			destroy(node->_rchild);
		}
		delete node;
		node = nullptr;
	}
}

template<typename T>
inline BSNode<T>* BStree<T>::prev(BSNode<T>* node)
{
	
	if (node->_lchild != nullptr)//如果node有左子树，找它的左右子树
	{
		BSNode<T>* pnode = node->_lchild;
		while (pnode->_rchild != nullptr)
		{
			pnode = pnode->_rchild;
		}
		return pnode;
	}
	else
	{
		//做过不存在左子树
		while (node->_parent != nullptr && node->_parent->_lchild == node)
		{
			node = node->_parent;
		}
		return node->_parent;
	}
}

template<typename T>
inline BSNode<T>* BStree<T>::succ(BSNode<T>* node)
{
	if (node->_rchild != nullptr)
	{
		BSNode<T>* pnode = node->_rchild;
		while (pnode->_lchild!=nullptr)
		{
			pnode = pnode->_lchild;
		}
		return pnode;

	}
	else
	{
		while (node!=nullptr&&node->_parent->_rchild)
		{
			node = node->_parent;
		}
		return node->_parent;
	}
	return NULL;
}

template<typename T>
inline BSNode<T>* BStree<T>::search(T key)
{
	return search(_root,key);                  // 这哥node是用来表明那个开始的位置的。
}

template<typename T>
inline BSNode<T>* BStree<T>::search(BSNode<T>* node, T key)
{
	while(node!=nullptr)
	{ 
		if (key == node->_value)
		{
			return node;
		}
		else if(key>node->_value)
		{
			node = node->_rchild;
		}
		else
		{
			node = node->_lchild;
		}
	}
	return nullptr;
}

template<typename T>
inline BSNode<T>* BStree<T>::find_min()
{
	return find_min(_root);
}

template<typename T>
inline BSNode<T>* BStree<T>::find_min(BSNode<T>* node)
{
	while (node->_lchild != nullptr)
	{
		node = node->_lchild;
	}
	return node;
}

template<typename T>
inline BSNode<T>* BStree<T>::find_max()
{
	return find_max(_root);
}

template<typename T>
inline BSNode<T>* BStree<T>::find_max(BSNode<T>* node)
{
	while (node->_rchild!=nullptr)
	{
		node = node->_rchild;
	}
	return node;
}

template<typename T>
inline void BStree<T>::preOrder(BSNode<T>* node)
{
	BSNode<T>* pnode = node;
	if (pnode != nullptr)
	{
		std::cout << pnode->_value << std::endl;
		preOrder(pnode->_lchild);
		preOrder(pnode->_rchild);
	}
}

template<typename T>
inline void BStree<T>::midOrder(BSNode<T>* node)
{
	if (node != nullptr)
	{
		midOrder(node->_lchild);
		std::cout << node->_value << std::endl;
		midOrder(node->_rchild);
	}
}

```

