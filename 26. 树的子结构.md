# [树的子结构](https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

力扣上很多树的题目都是可以用递归很快地解决的，而这一系列递归解法中蕴含了一种很强大的递归思维：对称性递归(symmetric recursion)
什么是对称性递归？就是对一个对称的数据结构（这里指二叉树）从整体的对称性思考，把大问题分解成子问题进行递归，即不是单独考虑一部分(比如树的左子树)，而是同时考虑对称的两部分(左右子树)，从而写出对称性的递归代码

题型分类：
可以用对称性递归解决的二叉树问题大多是判断性问题(bool类型函数),这一类问题又可以分为以下两类：
1、不需要构造辅助函数。这一类题目有两种情况：第一种是单树问题，且不需要用到子树的某一部分(比如根节点左子树的右子树)，只要利用根节点左右子树的对称性即可进行递归。第二种是双树问题，即本身题目要求比较两棵树，那么不需要构造新函数。该类型题目如下：
100. 相同的树
226. 翻转二叉树
104. 二叉树的最大深度
110. 平衡二叉树
543. 二叉树的直径
617. 合并二叉树
572. 另一个树的子树
965. 单值二叉树

2、需要构造辅助函数。这类题目通常只用根节点子树对称性无法完全解决问题，必须要用到子树的某一部分进行递归，即要调用辅助函数比较两个部分子树。形式上主函数参数列表只有一个根节点，辅助函数参数列表有两个节点。该类型题目如下：
101. 对称二叉树
剑指 Offer 26. 树的子结构

解题模板
下面给出二叉树对称性递归的解题模板
1、递归结束条件：特殊情况的判断
如果是单树问题，一般来说只要进行以下判断：


if(!root) return true/false;
if(!root->left) return true/false/递归函数;
if(!root->right) return true/false/递归函数;
如果是双树问题(根节点分别为p,q)，一般来说进行以下判断：


if(!p && !q)return true/false;
if(!p || !q)return true/false;
当然也不完全是这些情况，比如有的需要加上节点值的判断，需要具体问题需要具体分析

2、返回值
通常对称性递归的返回值是多个条件的复合判断语句
可能是以下几种条件判断的组合：
节点非空的判断
节点值比较判断
(单树)调用根节点左右子树的递归函数进行递归判断
(双树)调用两棵树的左右子树的递归函数进行判断

题目解读
空谈比较抽象，下面我们就对具体题目进行分析以及代码呈现
100. 相同的树
相同的树：比较两棵树是否相同
特殊判断：如果两棵树都是空树那么必然相同；如果两棵树其中只有一棵树为空树那么必不相同
返回值：两棵树都非空+根节点值相同+左子树相同+右子树相同
c++代码如下：


bool isSameTree(TreeNode*p, TreeNode*q)
{
    if (!p && !q)
        return true;
    return p && q && p->val == q->val && (isSameTree(p->left, q->left)) && (isSameTree(p->right, q->right));
}
104. 二叉树的最大深度
求二叉树最大深度
特殊判断：空树的最大深度为0
返回值：树非空，那么最大深度就是左子树最大深度和右子树最大深度的较大者加上根节点的1
代码如下：


int height(TreeNode*root)
{
    if (!root)
        return 0;
    else
        return max(height(root->left), height(root->right)) + 1;
}
110. 平衡二叉树
判断一棵树是不是平衡二叉树
平衡二叉树定义：左右子树最大高度差<=1
特殊判断：空树是平衡树
返回值：根节点的左右子树高度差<=1 + 左子树是平衡二叉树 +右子树是平衡二叉树
代码如下：(height函数即上一题的代码)


bool isBalanced(TreeNode*&root)
{
    if (!root)
        return true;
    return abs((height(root->left) - height(root->right)) <= 1) && isBalanced(root->left) && isBalanced(root->right);
}
965. 单值二叉树
单值二叉树：所有节点值均相等
特殊判断：1、空树是单值二叉树 2、如果左子树非空且根节点的值异与左子节点值(即根节点与左子节点不同)，返回false,右子树同理
返回值：左子树是单值二叉树+右子树是单值二叉树
代码如下：


bool isUnivalTree(TreeNode*root)
{
    if (!root) 
        return true;
    if ((root->left && root->left->val != root->val) || (root->right && root->right->val != root->val))
        return false; 
    return isUnivalTree(root->left) && isUnivalTree(root->right);
}
572. 另一个树的子树
判断一个数是不是另一颗树的子树
特殊判断：有一颗树为空就不成立
这道题的思路比较特殊，先判断两棵树是否是相同，如果相同那么就是满足题意的，
然后判断一棵树的左子树是否是另一颗树的子树/一棵树的右子树是否是另一颗树的子树


bool isSubtree(TreeNode*root1, TreeNode*root2)
{
    if (!root1 || !root2)
        return false;
    if (isSameTree(root1, root2))
        return true;
    return isSubtree(root1->left, root2) || isSubtree(root1->right, root2);
}
226. 翻转二叉树
将一棵二叉树镜像翻转
特殊判断：空树的镜像翻转树仍然是本身
思路：翻转左子树后替换右子树，翻转右子树后替换左子树
代码：


TreeNode*invertTree(TreeNode*root)
{
    if (!root)
        return nullptr;
    TreeNode*left = invertTree(root->left);
    TreeNode*right = invertTree(root->right);
    root->left = right;
    root->right = left;
    return root;
}
617. 合并二叉树
合并二叉树：将两个二叉树合并
思路：1、都是空树返回nullptr 2、其中有一个空返回另一个树的根节点
3、都不空的话先把两棵树根节点值相加，然后递归合并左右子树(以第一棵树为合并后的树)
代码如下：


TreeNode*mergeTrees(TreeNode*root1, TreeNode*root2)
{
    if (!root1)
        return root2;
    if (!root2)
        return root1;
    if (root1 && root2)
        root1->val += root2->val;
    root1->left = mergeTrees(root1->left, root2->left);    //递归合并左子树
    root1->right = mergeTrees(root1->right, root2->right); //递归合并右子树
    return root1;
}
剑指 Offer 28. 对称的二叉树
判断一棵树是否为对称二叉树
思路：构造一个辅助函数判断两棵树是否是镜像对称的，然后题目只要判断两棵这个树是否镜像对称
而比较两棵树是否镜像对称，即一棵树的左子树和另一棵树的右子树，以及一棵树的右子树和另一棵树的左子树是否镜像对称
特殊判断：都是空树满足条件；其中有一棵空树不满足条件
代码如下：


bool isSymmetric(TreeNode*root)
{
    return isMirror(root, root);
}

bool isMirror(TreeNode*p, TreeNode*q)
{
    if (!p && !q)
        return true;
    if (!p || !q)
        return false;
    return (p->val == q->val) && (isMirror(p->left, q->right)) && (isMirror(p->right, q->left));
}
剑指 Offer 26. 树的子结构
判断一棵树是否是另一棵树的子结构，注意子结构与子树的区别
子结构不能只利用根节点进行对称性递归，需要构造辅助函数，判断当两棵树根节点值相同时一棵树是否为另一棵树子结构


// hasSubStructure函数是判断如果A,B根节点相同，B是不是A的子结构
bool hasSubStructure(TreeNode*A, TreeNode*B)
{
    if (!B)        //递归结束条件1：A的一个节点B的对应位置没有,可以认为是子结构
        return true;
    if (!A || A->val != B->val)  //递归结束条件2：B的一个节点A的对应位置没有 / A,B对应位置节点值不同，此时必然不可能是子结构
        return false;
    return hasSubStructure(A->left, B->left) && hasSubStructure(A->right, B->right); //返回值：继续在对应位置递归判断
}


bool isSubStructure1(TreeNode<T> *A, TreeNode<T> *B)
{
    if (!A || !B)   //特殊判断
        return false;
    // 根节点相同的话直接进入比较，根节点不相同看B是不是A的左/右子树的子结构
    return hasSubStructure(A, B) || isSubStructure1(A->left, B) || isSubStructure1(A->right, B);
}

作者：eh-xing-qing
链接：https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```java
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        bool result = false;
        if(pRoot1 != nullptr && pRoot2 != nullptr)
        {
            if(pRoot1->val == pRoot2->val)
                result = isSubtree(pRoot1, pRoot2);
                
            if(!result)
                result = HasSubtree(pRoot1->left, pRoot2);
            
            if(!result)
                result =HasSubtree(pRoot1->right, pRoot2);
        }
        return result;
    }
    
    bool isSubtree(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        if(pRoot2 == nullptr)
            return true;
        
        if(pRoot1 == nullptr)
            return false;

        if(pRoot1->val != pRoot2->val)
            return false;

        return isSubtree(pRoot1->left, pRoot2->left)
            && isSubtree(pRoot1->right, pRoot2->right);
    }
};
```

## dfs模板，

```c++
//深度优先遍历这是迭代的需要用到栈
void depthFirstSearch(Tree root){
    stack<Node *> nodeStack;  //使用C++的STL标准模板库
    nodeStack.push(root);
    Node *node;
    while(!nodeStack.empty()){
        node = nodeStack.top();
        printf(format, node->data);  //遍历根结点
        nodeStack.pop();
        if(node->rchild){
            nodeStack.push(node->rchild);  //先将右子树压栈
        }
        if(node->lchild){
            nodeStack.push(node->lchild);  //再将左子树压栈
        }
    }
}
//dfs和前中后续的遍历还是不一样的，一个是从上下比，一个是在同一个三个节点内谁先。具体体现在dfs是从栈中去除后进行操作
//前序遍历是在入栈之前就进行操作了。
```

bfs模板 这个是迭代的，所以需要用到队列

```c++
void breadthFirstSearch(Tree root){
    queue<Node *> nodeQueue;  //使用C++的STL标准模板库
    nodeQueue.push(root);
    Node *node;
    while(!nodeQueue.empty()){
        node = nodeQueue.front();
        nodeQueue.pop();
        printf(format, node->data);
        if(node->lchild){
            nodeQueue.push(node->lchild);  //先将左子树入队
        }
        if(node->rchild){
            nodeQueue.push(node->rchild);  //再将右子树入队
        }
    }
}

```

若是采用递归的，模板应该是啥？

```c++
void PreorderRecursive(Bitree root){
  if (root) {
    visit(root);
    PreorderRecursive(root->lchild); 
    PreorderRecursive(root->rchild); 
  }
}
```

前序、中序和后续就是深度优先的一种，他们都是一股脑的走到底，但是呢，前序就是先写，中序

![image-20210625103207557](C:\Users\lisunyang\AppData\Roaming\Typora\typora-user-images\image-20210625103207557.png)

中序

![image-20210625103243364](C:\Users\lisunyang\AppData\Roaming\Typora\typora-user-images\image-20210625103243364.png)

后序

![image-20210625103314687](C:\Users\lisunyang\AppData\Roaming\Typora\typora-user-images\image-20210625103314687.png)

//前序的迭代算法



```c++
//前序遍历 --递归
template<typename T>
void preorder(Node<T> *&rootNode)
{
	if (!rootNode)
		return;
	//根->左->右
	std::cout << rootNode->value << " ";
	preorder(rootNode->left);
	preorder(rootNode->right);
}
 
//前序遍历 --栈           //前序遍历是入栈之前进行访问，注意因此刚开始不能对根节点进行入栈。
template<typename T>
void preorder2(Node<T> *&rootNode)
{
	std::stack<Node<T>*> nodeStack;
	Node<T> *tempNode = rootNode;
 
	while (!nodeStack.empty() || tempNode)
	{
		if (tempNode) { 
			std::cout << tempNode->value<<" ";
			nodeStack.push(tempNode);
			tempNode = tempNode->left;//根->左
		}
		else { 
			tempNode = nodeStack.top();
			nodeStack.pop();
			tempNode = tempNode->right;//右
		}
	}
}
```

```c++
//中序遍历 --递归
template<typename T>
void inorder(Node<T> *&rootNode)
{
	if (!rootNode)
		return;
	//左->根->右	
	inorder(rootNode->left);
	std::cout << rootNode->value << " ";
	inorder(rootNode->right);
}
 
//中序遍历 --栈
template<typename T>
void inorder2(Node<T> *&rootNode)
{
	std::stack<Node<T>*> nodeStack;
	Node<T> *tempNode = rootNode;
 
	while (!nodeStack.empty() || tempNode)
	{
		if (tempNode) {
			nodeStack.push(tempNode);
			tempNode = tempNode->left;//左
		}
		else {
			tempNode = nodeStack.top();
			nodeStack.pop();
			std::cout << tempNode->value << " "; //中序遍历是出栈之后进行访问
			tempNode = tempNode->right;//根->右
		}
	}
}
```

```c++
//后序遍历的非递归实现是三种遍历方式中最难的一种。由于在后序遍历中，要保证左孩子和右孩子都已被訪问而且左孩子在右孩子前訪问才干訪问根结点，这就为流程的控制带来了难题。以下介绍两种思路。
//后序遍历 --递归
template<typename T>
void postorder(Node<T> *&rootNode)
{
	if (!rootNode)
		return;
	//左->右->根	
	postorder(rootNode->left);
	postorder(rootNode->right);
	std::cout << rootNode->value << " ";
}
 
//后序遍历 --栈
template<typename T>
void postorder2(Node<T> *&rootNode)
{
	std::stack<Node<T>*> nodeStack;
	Node<T> *curNode = rootNode; //当前节点
	Node<T> *preNode = nullptr; //之前访问过的节点，用来存
 
	//把cur移动到左子树最下边
	while (curNode)
	{
		nodeStack.push(curNode);
		curNode = curNode->left;               
	}
	while (!nodeStack.empty())
	{
		//走到这里，cur空，并已经遍历到左子树底端
		curNode = nodeStack.top();
		nodeStack.pop();
		//无右或右已访问才访问根节点
		if (!curNode->right || curNode->right == preNode){
			std::cout << curNode->value << " ";
			preNode = curNode;
		}
		//右子树未访问
		else{
			//根节点再次入栈
			nodeStack.push(curNode);
			//进入右子树
			curNode = curNode->right;
			//把cur移动到右子树的左子树最下边
			while (curNode)
			{
				nodeStack.push(curNode);
				curNode = curNode->left;
			}
		}
	}
}
```

//前中后序遍历都是DFS，就是都要往深入进行挖，不凭着挖，三个的区别就是前序是看到节点先进入，中序是回来的时候才进入，后续的回来第二次的时候才进入。