# [最小的K个数](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=13&tqId=11182&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。



对于经典TopK问题，本文给出 4 种通用解决方案。

解题思路：
一、用快排最最最高效解决 TopK 问题：
二、大根堆(前 K 小) / 小根堆（前 K 大),Java中有现成的 PriorityQueue，实现起来最简单：
三、二叉搜索树也可以 解决 TopK 问题哦
四、数据范围有限时直接计数排序就行了：
一、用快排最最最高效解决 TopK 问题：O(N)O(N)

作者：sweetiee
链接：https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





### assign()功能函数实现截取

取数组中的几个连续的变量，可以用assign

```java
class Solution {
public:
    /*
     * 两种方法：第一种是基于partition函数的方法，使得比第K个数字小的都位于其左边。
     * 第二种方法不用修改输入的数组，可以使用multiset完成，容器中元素个数小于k
     * 加入，大于k，和最大的比较，小于最大的，那么就删除最大的，把它加入
     */
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        vector<int> res;
        int size = input.size();
        if(size == 0 || k > size)
            return res;
        
        multiset<int, greater<int>> set;
        
        
        for(int val : input)
        {
            if(set.size() < k)
            {
                set.insert(val);
            }
            else
            {
                if(val < *(set.begin()))
                {
                    set.erase(set.begin());
                    set.insert(val);
                }
            }
        }

        for(int val : set)
            res.push_back(val);
        
        return res;
        
    }
};
```

# 快速排序



```c++
void quickSortIn(vector<int> &nums, int l, int r)
{
    
      //取最左边位基准
        if (l >= r) return;                       //注意点1  l有可能>r 因为
        // 哨兵划分操作（以 arr[l] 作为基准数）       //注意点2：以左右为基准不同while的循环顺序也不同
        int i = l, j = r;
        
    while (i < j)             //循环的终止条件是i==j
    {
        while (i < j&&nums[j] >= nums[l])    //这里可以注意的是外面有i<j 里面也需要，因为里面while循环会改变i,j
        {
            j--;
        }
        while (i < j&&nums[i] <= nums[l])       //注意点3，循环停止的位置 ，i,j互相靠拢，但是最后一个值与nums[l]
        {
            i++;                                //收敛要注意与之相比要小才行，后面需要交换
        }                                       //需要保证nums[i]<nums[l]
        cout<<nums[i]<<" "<<nums[l]<<endl;      //i走动表示从小变大，因为小的要交换
        swap(nums[i],nums[j]);
    }
    swap(nums[l],nums[i]);
    quickSortIn(nums,l,i-1);
    quickSortIn(nums,i+1,r);
}
void quickSortOut(vector<int> &nums)
{
    quickSortIn(nums,0,nums.size()-1);
}
```

