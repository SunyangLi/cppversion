# [数据流中的中位数](https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tqId=11216&tPage=4&rp=4&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。

大定推的数据结构是其父节点都比子节点要大

小顶堆是都小

在stl中有优先队列，其用到了堆这个数据结构   ，关于优先队列的数据结构

因为顶推其底层的数据结构还是数组



//堆的数据结构

//

![image-20210707101633332](C:\Users\lisunyang\AppData\Roaming\Typora\typora-user-images\image-20210707101633332.png)



```java
class Solution {
public:
    vector<int> numbers;
    /* 使用upper_bound对vector进行有序插入 */
    void Insert(int num)
    {
        /* 返回大于num的第一个元素位置 */
        auto pos = upper_bound(numbers.begin(), numbers.end(), num);
        numbers.insert(pos, num);
    }

    double GetMedian()
    { 
        int size = numbers.size();
        if(size == 0)
            return 0.0;
        if(size % 2 != 0)
            return numbers[size / 2];
        return (numbers[size / 2] + numbers[size / 2 - 1]) / 2.0;
    }

};
```

推就是一个东西    有序的vector 用完全二叉树来表示就好，完全二叉树就是层序遍历 遍历到null就结束。



```c++
class MedianFinder {
public:
    // 最大堆，存储左边一半的数据，堆顶为最大值
    priority_queue<int, vector<int>, less<int>> maxHeap;
    // 最小堆， 存储右边一半的数据，堆顶为最小值
    priority_queue<int, vector<int>, greater<int>> minHeap;
    /** initialize your data structure here. */
    MedianFinder() {
    }

    // 维持堆数据平衡，并保证左边堆的最大值小于或等于右边堆的最小值
    void addNum(int num) {
        /*
         * 当两堆的数据个数相等时候，左边堆添加元素。
         * 采用的方法不是直接将数据插入左边堆，而是将数据先插入右边堆，算法调整后
         * 将堆顶的数据插入到左边堆，这样保证左边堆插入的元素始终是右边堆的最小值。
         * 同理左边数据多，往右边堆添加数据的时候，先将数据放入左边堆，选出最大值放到右边堆中。
         */
        if (maxHeap.size() == minHeap.size()) {
            minHeap.push(num);
            int top = minHeap.top();
            minHeap.pop();
            maxHeap.push(top);
        } else {
            maxHeap.push(num);
            int top = maxHeap.top();
            maxHeap.pop();
            minHeap.push(top);
        }
    }
    
    double findMedian() {
        if (maxHeap.size() == minHeap.size()) {
            return (maxHeap.top()+minHeap.top())*1.0/2;
        } else {
            return maxHeap.top()*1.0;
        }
    }
};
```

- Heap是一种数据结构具有以下的特点：
  1）**完全二叉树**；
  2）heap中存储的值是**偏序**；

- **Min-heap**: 父节点的值小于或等于子节点的值；
  **Max-heap**: 父节点的值大于或等于子节点的值；

   

  ![img](https://upload-images.jianshu.io/upload_images/650075-91f1549ff0c87c15.png)

   

   

------

1. **堆的存储：**
   一般都用数组来表示堆，i结点的父结点下标就为(i–1)/2。它的左右子结点下标分别为2 * i + 1和2 * i + 2。如第0个结点左右子结点下标分别为1和2。

    

   ![img](https://upload-images.jianshu.io/upload_images/650075-35f2934f850019d0.gif)

    

2. **堆的操作：insert**
   插入一个元素：新元素被加入到heap的末尾，然后更新树以恢复堆的次序。
   每次插入都是将新数据放在数组最后。可以发现从这个新数据的父结点到根结点必然为一个有序的数列，现在的任务是将这个新数据插入到这个有序数据中——这就类似于直接插入排序中将一个数据并入到有序区间中。

    

   ![img](https://upload-images.jianshu.io/upload_images/650075-68959377359ac140.png)

    

    

3. **堆的操作：Removemax**
   按定义，堆中每次都删除第0个数据。为了便于重建堆，实际的操作是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最大的，如果父结点比这个最小的子结点还大说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点将一个数据的“下沉”过程。

    

   ![img](https://upload-images.jianshu.io/upload_images/650075-87c918e6477027d2.png)

    

    

4. **堆的操作：buildHeap 堆化数组**
   对于叶子节点，不用调整次序，根据满二叉树的性质，叶子节点比内部节点的个数多1.所以i=n/2 -1 ，不用从n开始。

    

   ![img](https://upload-images.jianshu.io/upload_images/650075-df751f1773dc2e60.png)

    

    

5. **堆排序**
   堆建好之后堆中第0个数据是堆中最大的数据。取出这个数据再执行下堆的删除操作。这样堆中第0个数据又是堆中最大的数据，重复上述步骤直至堆中只有一个数据时就直接取出这个数据。

   

   ```c++
   void copyAdjust(vector<int> &nums, int size, int index)
   {
       int l = 2 * index + 1;
       int r = 2 * index + 2; //这里表示的是根节点从0开始
       int maxIndex = index;
       if (l < size && nums[l] > nums[maxIndex])
           maxIndex = l;
       if (r < size && nums[r] > nums[maxIndex])
           maxIndex = r;
       if (maxIndex != index)
       {
           swap(nums[index], nums[maxIndex]);
           copyAdjust(nums, size, maxIndex);
       }
   }
   
   void copySortHeap(vector<int> &nums)
   {
       //初步构造堆
       for (int i = nums.size() / 2 - 1; i >= 0; --i) //可以取画张图就知道了,root呀需要取到
       {
           copyAdjust(nums, nums.size(), i);  
       }
       for (int i = nums.size() - 1; i > 0; --i)
       {
           swap(nums[0], nums[i]);
           copyAdjust(nums, i, 0); //为啥这里是0????? 因为秩序要调整根节点就好
       }
   }
   ```

   本来想要试一试初始的从1开始的，但是失败了

   原因是前面那个adjust函数还可以，但是，因为在那里就没有流出空格，所以就不对了