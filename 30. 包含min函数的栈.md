# [包含min函数的栈](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&tqId=11173&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。



```java
class Solution {
public:
    void push(int value) {
        stackVal.push(value);
        if(stackMin.empty())
        {
           stackMin.push(value);
        }
        else if(stackMin.top() > value)
        {
            stackMin.push(value);
        }
        else
        {
            stackMin.push(stackMin.top());
        }
    }
    void pop() {
        if(!stackVal.empty())
        {
            stackVal.pop();
            stackMin.pop();
        }
    }
    int top() {
        return stackVal.top();
    }
    int min() {
        return stackMin.top();
    }
private:
    stack<int> stackVal;
    stack<int> stackMin;
};
```

```c++

```

单调栈就是***\*栈内元素单调递增或者单调递减\****的栈，单调栈只能在栈顶操作

```c++
stack<int> st;//单调栈
//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解
for (遍历这个数组)
{
	if (栈空 || 栈顶元素大于等于当前比较元素)
	{
		入栈;
	}
	else
	{
		while (栈不为空 && 栈顶元素小于当前元素)
		{
			栈顶元素出栈;
			更新结果;
		}
		当前数据入栈;
	}
}

```

```c++
int FieldSum(vector<int>& v)
{
	v.push_back(INT_MAX);/这里可以理解为需要一个无限高的人挡住栈中的人，不然栈中元素最后无法完全出栈
	stack<int> st;
	int sum = 0;
	for (int i = 0; i < (int)v.size(); i++)
	{
		if (st.empty() || v[st.top()] > v[i])//小于栈顶元素入栈
		{
			st.push(i);
		}
		else
		{
			while (!st.empty() && v[st.top()] <= v[i])
			{
				int top = st.top();//取出栈顶元素
				st.pop();
				sum += (i - top - 1);//这里需要多减一个1
			}
			st.push(i);
		}
	}
	return sum;
}
————————————————
版权声明：本文为CSDN博主「lucky52529」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/lucky52529/article/details/89155694
```

用处在：

单调栈的性质：

1.单调栈里的元素具有单调性

2.元素加入栈前，会在栈顶端把破坏栈单调性的元素都删除

3.***\*使用单调栈可以找到元素向左遍历第一个比他小的元素，也\*\*\*\*可以找到元素向左遍历第一个比他大的元素。\*\*\*\*\****

上面这两个通过单调增和单调减来进行维护