队列实现

## 循环队列

```c++
#pragma once
#define MAXSIZE 5
 
#include<cstdlib>
#include<cassert>
#include<iostream>
using namespace std;
 /*
 判断循环队列是“空”还是“满”，有以下两种处理方法：
1》设置状态标志位以区别空还是满
2》少用一个元素，约定“队头front在队尾rear的下一个位置（指的是环的下一个位置）”作为“满”的标志

注意以下几点，循环队列迎刃而解：
1》求元素的个数：(rear - front + MAXSIZE) % MAXSIZE
2》front/rear指向逻辑的下一个空间  front =（front+1)%MAXSIZE     rear = (rear+1)%MAXSIZE
3》判空：front == rear
4》判满：(rear+1+MAXSZIE) == front
————————————————
版权声明：本文为CSDN博主「zyh_helen」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zongyinhu/article/details/49801373
 */
template<class T>
class Queue
{
private:
	T *base;
	int front;
	int rear;
public:
	explicit Queue();
	virtual ~Queue();
	bool push(const T& value);
	bool pop();
	T& top();
	const T& top()const;
	size_t size()const;
	void clear();
	void destory();
protected:
	bool IsFull()const;
	bool IsEmpty()const;
};
template<class T>
Queue<T>::~Queue()
{
	destory();
}
 
template<class T>
void Queue<T>::destory()
{
	if (base != NULL)
	{
		delete[] base;
		base = NULL;
	}
}
 
template<class T>
void Queue<T>::clear()
{
	front = 0;
	rear = 0;
}
 
template<class T>
size_t Queue<T>::size()const
{
	return (rear - front + MAXSIZE) % MAXSIZE;
}
 
template<class T>
const T& Queue<T>::top()const
{
	return base[front];
}
 
template<class T>
T& Queue<T>::top()
{
	return base[front];
}
 
template<class T>
bool Queue<T>::IsFull()const
{
	return (rear + 1) % MAXSIZE == front;//约定：front在rear的下一个位置表示队列已满
}
 
template<class T>
bool Queue<T>::IsEmpty()const
{
	return front == rear;
}
 
template<class T>
Queue<T>::Queue()
{
	T *tmp = new T[MAXSIZE];
	assert(tmp != NULL);
	base = tmp;
	memset(base, 0, MAXSIZE*sizeof(T));
	front = 0;
	rear = 0;
}
 
template<class T>
bool Queue<T>::push(const T& value)
{
	if (IsFull())
	{
		cout << "the queue is already full,can not push anymore!" << endl;
		return false;
	}
	base[rear] = value;
	rear = (rear + 1) % MAXSIZE;
	return true;
}
 
template<class T>
bool Queue<T>::pop()
{
	if (IsEmpty())
	{
		cout << "the queue is already empty,it can not pop anymore!" << endl;
		return false;
	}
	front = (front + 1) % MAXSIZE;
	return true;
}
```

```c++
/*
C++队列是一种容器适配器，它给予程序员一种先进先出(FIFO)的数据结构。
1.back() 返回一个引用，指向最后一个元素
2.empty() 如果队列空则返回真
3.front() 返回第一个元素
4.pop() 删除第一个元素
5.push() 在末尾加入一个元素
6.size() 返回队列中元素的个数
*/

/*
front()：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。
back()：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。
push(const T& obj)：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。
push(T&& obj)：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。
pop()：删除 queue 中的第一个元素。
size()：返回 queue 中元素的个数。
empty()：如果 queue 中没有元素的话，返回 true。
emplace()：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。
swap(queue<T> &other_q)：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。
*/

//循环队列的c++ 实现
#include <iostream>
#include <queue>
#include <string>
using namespace std;

template <typename T>
class LoopQueue
{
public:
    LoopQueue(int c = 20); //c++ 类的成员函数默认参数必须在声明中给,普通函数怎么都可以.
    ~LoopQueue();
    bool isEmpty(); //队列的判空
    int size();     //队列的大小
    bool push(T t); //入队列
    bool pop();     //出队列
    T front();      //队首元素

private:
    int capacity;
    int begin;
    int end;
    T *queue;
};

template <typename T>
LoopQueue<T>::LoopQueue(int c)
    : capacity(c), begin(0), end(0), queue(nullptr)
{
    queue = new T[capacity];//基于数组
};

template <typename T>
LoopQueue<T>::~LoopQueue()
{
    delete[] queue;
}

template <typename T>
bool LoopQueue<T>::isEmpty() //判断循环队列是否为空
{
    if (begin == end)
        return true;
    return false;
};

template <typename T>
int LoopQueue<T>::size()
{
    return (end - begin + capacity) % capacity; //计算循环队列的长度
};

template <typename T>
bool LoopQueue<T>::push(T t)
{
    if (end + 1 % capacity == begin) //判断队列是否已满
    {
        return false;
    }
    queue[end] = t;
    end = (end + 1) % capacity;
    return true;
};

template <typename T>
bool LoopQueue<T>::pop() //判断队列是否为空
{
    if (end == begin)
    {
        return false;
    }
    begin = (begin + 1) % capacity;
    return true;
}

template <typename T>
T LoopQueue<T>::front()
{
    // if (end == begin)
    // {
    // 	return false;
    // }
    return queue[begin];
};
```

## 数组队列

```c++
#include <iostream>
#include <cstdlib>
using namespace std;
 
struct QNode    //定义队列结点的数据结构
{
	QNode *next; //指针域,指向下一个结点
	double data;    //数据域，存储队列信息
};
 
struct LinkQueue    //定义队列的数据结构
{
	QNode *front;      //队首指针,指向QNode类型的指针
	QNode *rear;       //队尾指针
};
 
void InitQueue(LinkQueue &Q)     //构造一个空的队列
{
	QNode *q;
	q = new QNode;    //申请一个结点的空间
	q->next = NULL;   //当作头结点
	//队首与队尾指针都指向这个结点，指针域为NULL
	Q.front = q;
	Q.rear = q;
}
 
int IsEmpty(LinkQueue &Q)    //判断队列是否为空
{
	if (Q.rear == Q.front)
		return 0;
	else
		return 1;
}
 
void EnQueue(LinkQueue &Q, double e)     //从队列尾部插入元素
{
	QNode *p;    //新创建一个结点
	p = new QNode;
	p->next = NULL;
	p->data = e;  //输入数据信息
	//将新结点插入队列尾部
	Q.rear->next = p;
	Q.rear = p;       //设置新的尾结点
}
 
void DeQueue(LinkQueue &Q, double &e)   //从队列首部删除一个结点
{
	QNode *p;
	p = Q.front->next;
	e = p->data;    //保存要出队列的数据
	Q.front->next = p->next;       //将下一个结点当作头结点后面链接的第一个结点
	if (Q.rear == p)    //如果要删除的元素即为尾结点，则将头指针赋予尾指针，一同指向头结点，表示队列为空
		Q.rear = Q.front;
	delete p;
}
 
void DestoryQueue(LinkQueue &Q)       //销毁一个队列
{
	while (Q.front)
	{
		Q.rear = Q.front;    //从头节点开始，一个一个删除队列结点，释放空间
		delete Q.front;
		Q.front = Q.rear;
	}
}
int main()
{
	LinkQueue *Q;  //定义一个队列Q
	Q = new LinkQueue;
	InitQueue(*Q);
	cout << "开始往队列里输入数据，以-1作为结束符" << endl;
	cout << "请输入一个数：" << endl;
	double a, x;
	cin >> a;
	while (a != -1)
	{
		EnQueue(*Q, a);
		cout << "请输入一个数：" << endl;
		cin >> a;
	}
	//输出队列元素,队首->队尾
	QNode *p;
	p = Q->front->next;
	if (p == NULL)     //如果为空表，直接退出
	{
		cout << "队列为空！" << endl;
		return 0;
	}
	cout << "队列数据依次为：" << endl;
	while (p != NULL)
	{
		cout << p->data << " ";
		p = p->next;
	}
	cout << endl;
	//删除队列元素
	while (!IsEmpty(*Q))
	{
		DeQueue(*Q, x);
		cout << x << " ";
	}
	//释放内存空间
	delete Q->front;
	delete Q;
	system("pause");
	return 0;
}
```

1、循环队列中判断队空的方法是判断front==rear，队满的方法是判断front=（rear+1）%MAXSIZE。（为什么不用一个length表示队长，当length==maxSize时表示队满，原因就是，在频繁的队列操作中，多出一个变量会大量的增加执行时间，所以不如浪费一个数组空间来得划算。）

       2、用单链表表示的链式队列特别适合于数据元素变动较大的情形，而且不存在溢出的情况。
————————————————
版权声明：本文为CSDN博主「GeekZW」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zichen_ziqi/article/details/80819939