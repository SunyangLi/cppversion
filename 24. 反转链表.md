# [反转链表](https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一个链表，反转链表后，输出新链表的表头。



```java
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
        if(pHead == nullptr)
            return nullptr;
        
        ListNode* preNode = nullptr;
        auto curNode = pHead;
        
        while(curNode)
        {
            auto nextNode = curNode->next;
            curNode->next = preNode;
            preNode = curNode;
            curNode = nextNode;
        }
        
        return preNode;
    }
};
```

```c++
   //1、迭代反转列表法，需要三个指针
    //当前链表的首元节点开始，一直遍历至链表的最后一个节点，这期间会逐个改变所遍历到的节点的指针域，另其指向前一个节点
    ListNode* iterationReverseList(ListNode *head)
    {
        ListNode* prev=nullptr;
        ListNode* next;
        while(head)
        {
            next=head->next;
            head->next=prev;
            prev=head;
            head=next;
            
            
        }
        return prev;  
    }
    //最终返回的节点是prev,因为head已经是空了
    
    //2、递归反转链表
    //递归反转法的实现思想是从链表的尾节点开始，依次向前遍历，遍历过程依次改变各节点的指向，即另其指向前一个节点
    ListNode* recursiveReverse(ListNode* head)
    {
        //递归结束
        if(head==nullptr||head->next==nullptr)
        {
            return head;                        //空链或者有只有一个节点
        }
        ListNode *newhead = recursiveReverse(head->next);
        //当逐层退出时，new_head 的指向都不变，一直指向原链表中最后一个节点；
        //递归每退出一层，函数中 head 指针的指向都会发生改变，都指向上一个节点。
        //每退出一层，都需要改变 head->next 节点指针域的指向，同时令 head 所指节点的指针域为 NULL。
        head->next->next=head;
        head->next=nullptr;
        return newhead;

    }
    //可以补一张图
    //3、头插法
    ListNode* headReverse(ListNode*head)
    {
        ListNode *newhead=nullptr;
        ListNode *temp;
        if(head == nullptr||head->next==nullptr)
        {
            return head;
        }
        while(head)
        {
            temp=head;
              //将 temp 从 head 中摘除
            head=head->next;//更新

            temp->next=newhead; //temp是要插在节点的前面，然后更新temp
            newhead=temp;
        }
        return newhead;
    }
    //4、就地反转法,多两个指针
    ListNode * localRreverse(ListNode * head) {
    ListNode * beg = NULL;
    ListNode * end = NULL;
    if (head == NULL || head->next == NULL) {
        return head;
    }
    beg = head;
    end = head->next;
    while (end != NULL) {
        //将 end 从链表中摘除
        beg->next = end->next;
        //将 end 移动至链表头
        end->next = head;
        head = end;
        //调整 end 的指向，另其指向 beg 后的一个节点，为反转下一个节点做准备
        end = beg->next;
    }
    return head;
}

```

递归的样子

![image-20210622085236758](C:\Users\lisunyang\AppData\Roaming\Typora\typora-user-images\image-20210622085236758.png)

然后就可以配合

```
head->next->next=head;
head->next=nullptr;
```

```c++
ListNode reverse(ListNode head) {
    if (head.next == null) return head;
    ListNode last = reverse(head.next);
    head.next.next = head;
    head.next = null;
    return last;
}
```

