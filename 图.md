链接

http://blog.sina.com.cn/s/blog_65e736c30100y6y1.html

### Dijkstra 算法详解

Dijkstra 算法是一个基于「贪心」、「广度优先搜索」、「动态规划」求一个图中一个点到其他所有点的最短路径的算法，时间复杂度 O(n2)

//几个点

一个应该是对于原来的更新，其实就是对于那个矩阵进行了一个按行遍历操作，然后更新dis就好了

注意更新的时候dis要对visit和unvisit进行一个区分就好

还没由对路径进行一个显示，由于业务不熟练，些了好多应该可以改进的东西

```c++
#include <iostream>
#include <vector>
using namespace std;
#include <algorithm>
#include <assert.h>
#define MAX_NUM 10000
void printOneDimen(vector<int> const &vec)
{
    for (auto const &s : vec)
    {
        cout << s << " ";
    }
    cout << endl;
}
void printTwoDimen(vector<vector<int>> matrix)
{
    for (auto const &m : matrix)
    {
        for (auto const &n : m)
        {
            cout << n << " ";
        }
        cout << endl;
    }
}
void setZeroInDiag(vector<vector<int>> &matrix)
{
    int m = matrix.size();
    int n = matrix[0].size();
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (i == j)
            {
                matrix[i][j] = 0;
            }
        }
    }
}
void setSymmetry(vector<vector<int>> &matrix)
{
    int m = matrix.size();
    int n = matrix[0].size();
    for (int i = 0; i < m; i++)
    {
        for (int j = 0; j < n; j++)
        {
            if (i > j)
            {
                matrix[i][j] = matrix[j][i];
            }
        }
    }
}
vector<int> findMinExcept0(vector<int> const &vec, vector<int> const &visit) //visitvia是index
{
    int size = vec.size();
    vector<int> ret{-1, -1};
    int min = MAX_NUM;
    for (int i = 0; i < size; i++)
    {
        if (count(visit.begin(), visit.end(), i))
        {
            continue;
        }
        if (vec[i] < min)
        {
            min = vec[i];
            ret[0] = i;
            ret[1] = min;
        }
    }
    return ret;
}
void pullBorder(vector<int> &vec)
{
    for (auto &x : vec)
    {
        if (x > MAX_NUM)
        {
            x = MAX_NUM;
        }
    }
}
vector<int> compareVector(vector<int> const &old, vector<int> const &cal)
{
    vector<int> ret;
    int size = old.size();
    assert(size == cal.size());
    auto min = ([](int x, int y)
                { return x < y ? x : y; });
    for (int i = 0; i < size; i++)
    {
        int val = min(old[i], cal[i]);
        ret.push_back(val);
    }
    return ret;
}

void removeElem(vector<int> &vec, int index)
{

    for (int i = 0; i < vec.size(); ++i)
    {
        if (index == vec[i])
        {
            vec.erase(vec.begin() + i);
            break;
        }
    }
}
void intMap2char(vector<int> const &visit)
{
    string str = "abcdef";
    for (int i = 0; i < str.size(); i++)
    {
        cout << str[visit[i]] << " ";
    }
    cout << endl;
}

int main()
{
    int m = 6;
    int n = 6;
    vector<vector<int>> matrix(m, vector<int>(n, MAX_NUM)); //左边是行数，右边是列数
    setZeroInDiag(matrix);
    /* A  B  C  D  E  F
    A  0  6  3  M  M  M
    B  6  0  2  5  M  M
    C  3  2  0  3  4  M
    D  M  5  3  0  2  3
    E  M  M  4  2  0  5
    F  M  M  M  3  5  0
    */
    matrix[0][1] = 6;
    matrix[0][2] = 3;
    matrix[1][2] = 2;
    matrix[2][3] = 3;
    matrix[3][4] = 2;
    matrix[3][5] = 3;
    matrix[4][5] = 3;
    setSymmetry(matrix);
    cout << "打印原始数据" << endl;
    printTwoDimen(matrix);

    /* 0 1 2 3 4 5 
       A B C D E F
    */
    // define
    vector<int> temp;
    for (int i = 0; i < m; i++)
    {
        temp.push_back(i);
    }

    vector<int> visit{temp.front()}; //注意这个构造需用用{}，temp。front传递的是引用
    //cout<<<<endl;
    printOneDimen(visit);
    auto it1 = temp.begin() + 1;
    auto it2 = temp.end();
    vector<int> unvisit(it1, it2);

    //printOneDimen(unvisit);
    vector<int> dis = matrix[0]; //定义一个距离
    vector<vector<int>>Road;
    //更新路径的距离
    int count = 0;
    while(!unvisit.empty())
    {
        vector<int> ret = findMinExcept0(dis, visit); //ret第一个元素表示key ret的第二个元素表示value
        visit.push_back(ret[0]);
        vector<int> mid = matrix[ret[0]];
        for_each(mid.begin(), mid.end(), [ret](int &x)
                 { x += ret[1]; });
        pullBorder(mid);
        dis = compareVector(dis, mid);
        removeElem(unvisit, ret[0]);
    }
    printOneDimen(dis);
    //printOneDimen(visit);
    intMap2char(visit);


    //原来的distance与现在的dis进行比较，只需要更新在unvisit的距离
    //还没把路径给更新出来
}
```

