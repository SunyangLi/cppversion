# [第一个只出现一次的字符位置](https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=11187&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）。



```java
class Solution {
public:
    /* hash表的典型应用 */
    int FirstNotRepeatingChar(string str) {
        unordered_map<char, int> map;
        for(char ch : str)
            map[ch]++;
        
        int length = str.length();
        for(int i = 0; i < length; ++i)
        {
            if(map[str[i]] == 1)
                return i;
        }
        return -1;
    }
};
```

```c++
char firstUniqChar(string s) 
    {
        unordered_map<char,int> map;
        int size=s.size();
        for(int i=0;i<size;i++)
        {
            map[s[i]]++;
        }
        for(int i=0;i<size;i++)
        {
            if(map[s[i]]==1)
            {
                return s[i];
            }
        }
        //char s=' ';
        return ' ';

    }
```

队列具有「先进先出」的性质，因此很适合用来找出第一个满足某个条件的元素。

//下面的不太行，不能找到第一次的位置，第一次还是需要用一些东西来记录下来的

```
class Solution {
public:
    char firstUniqChar(string s) {
        unsigned int result[128]{0};  //char不会超过128，因此建立一个128大小的unsigned int数组
        for(const char& ch : s)  //遍历每一个字符，统计每一个字符出现的次数
            ++result[ch];  //字符出现次数+1，题目说明s的长度小于50000，所以不会产生溢出，可以放心使用
        for(int i = 0; i < s.size(); ++i)  //从前往后扫描字符串
        {
            if(result[s[i]] == 1)  //找到了仅出现一次的字符
                return s[i];       //返回结果
        }
        return ' ';  //没有符合要求的字符，返回' '
    }
};

作者：xi-yu-shi-liu-guang-3
链接：https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/solution/cyong-shu-zu-shi-xian-ha-xi-biao-by-xi-yu-shi-liu-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```

//其实下面的是一个vector 用i来代表出现的位置   ，只要有i，就可以不用出现的次数了

```c++
class Solution {
public:
    char firstUniqChar(string s) {
        if(s.empty()) return ' ';
        int m[26]{}; //重复了设置为50000，0设置为没出现
        int res=INT_MAX;
        for(int i =0;i<s.size();++i){
            if(m[s[i]-'a']==50000) continue; //如果已经重复，跳过设置
            else if(m[s[i]-'a']==0) m[s[i]-'a']=i+1; //如果没出现过，设置为出现在字符的第几位,从1计数
            else if(m[s[i]-'a']!=0) m[s[i]-'a']=50000; //如果已经出现了一次，设置为50000
        }
        
        for(int j=0;j<26;++j){
            if(m[j]==0) continue; //没有出现过
            else if(m[j]==50000) continue; //重复出现过
            else  res = min(res,m[j]); //只出现了一次，m[j]存了出现的位置
        }
        return res==INT_MAX?' ':s[res-1];
    }
};

作者：mystitch626
链接：https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/solution/cyong-26wei-shu-zu-ji-lu-zhong-fu-wei-ch-585u/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

这里需要注意的是字符串和数组1，2，3，4这种像映射，可以用 ch-'a'这种来算

注意下最大值的选取，若最大值选取size,则会在i=1的时候造成冲突