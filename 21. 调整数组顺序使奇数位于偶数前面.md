# [调整数组顺序使奇数位于偶数前面](https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。



思路：从后向前遍历，遇到奇数在偶数后边，就交换调整   O($n^2$)

//为啥需要从后向前遍历？

```java
class Solution {
public:
    void reOrderArray(vector<int> &array) {
        //4 3 7  8 5 9 7 1   3 7 5 9 7 1 4 8
        int size = array.size();
        for(int i = 0; i < size; ++i)
        {
            for(int j = size - 1; j > i; --j)
            {
                if(array[j] % 2 != 0 && array[j - 1] % 2 == 0)//这里可以不越界
                    swap(array[j], array[j - 1]);
            }
        }
        
    }
};
```

//上述类似于排序的方法，找到一个就放好位置，因此是用n2的时间

```c++
void reOrderArrayFromLeft(vector<int> &array)
{
    //4 3 7  8 5 9 7 1   3 7 5 9 7 1 4 8
    //由
    int size = array.size();
    cout<<"size="<<size<<endl;
    for (int i = 0; i <size; ++i)
    {
        for (int j = 0; j <= i; j++)  //注意这里的=号，取了就会对下面造成影响，不取就是少计算一个边界？
        {
            if (array[j] % 2 == 0 && array[j + 1] % 2 == 1)//为啥这里不需要考虑数组越界？这里确实越界了
            {
                swap(array[j], array[j + 1]);
                cout<<"j+1="<<j+1<<" "<<"i="<<i<<endl;
            }
        }
    }
}
```



//如果不要求之间的相对顺序的画，可以用指针，一个指针从左，一个指针从右，左边的碰到偶数停，右边的碰到奇数挺

```c++
void reOrderArrayTwoPointers(vector<int> &array) //没有考虑之间的相对顺序
{
    int size = array.size();
    int left = 0;
    int right = size - 1;
    int stateleft = 0;
    int stateright = 0;
    while (left < right)
    {
        
        int stateleft = 0;
        int stateright = 0;
        if ((array[left] & 0x1) == 0)//左边是偶数
        {
            stateleft = 1;
        }
        if ((array[right] & 0x1) == 1) //右边是奇数
        {
            stateright = 1;
        }
        if (stateleft == 1 && stateright == 1)
        {
            swap(array[left], array[right]);
            left++;
            right--;
        }
        else if(stateright==1)
        {
            left++;
        }
        else
        {
            right--;
        }
        cout<<"right"<<stateright<<" "<<"left"<<stateleft<<endl;
        
    }
}
```

c++和c不会左越界检查，特比是使用[ ]扽时候

```c++
for(int i=0;i<9;++i)
    {
        cout<<V1.at(i)<<endl;
        
    }
    cout <<V1.at(16) << endl;
```

使用.at()可以在运行时帮助运行是越界

