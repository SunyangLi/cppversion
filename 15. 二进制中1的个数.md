# [二进制中1的个数](https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。



思路：使用位运算，核心思路就是 根据 n & (n - 1) 把最后一位1变成0，并更新n，然后计数，直到 n 为0。



```java
class Solution {
public:
     int NumberOf1(int n) {
         int count = 0;
         while (n)
         {
             n = n & (n - 1); // 把最后一位1变成0
             ++count;
         }
         return count;
     }
};
```

```c++
#include<iostream>
using namespace std;
#include<bitset>
int NumberOf1(int n) 
{
         int count = 0;
         while (n)
         {
             cout<<"第"<<count+1<<"次"<<bitset<32>(n)<<endl;
             n = n & (n - 1); // 把最后一位1变成0
             ++count;
         }
         return count;
}
int main()
{
    int a=65436;
    cout<<bitset<32>(a)<<endl;
    cout<<bitset<32>(a-1)<<endl;
    cout<<bitset<32>((a-1)&a)<<endl;
    //int b=NumberOf1(a);
    return 0;
}
```

把一个属用二进制输出可以用bitset<32>(x)这种

注意&的操作可以用作

```
int test_distance_hanming(int x,int y)
{
    int n=0;
    int res=x^y;
    while(res)
    {
        if(res&0x1)
        {
            n++;
        }
        res=res>>1;
        
    }
    return n;
}
```

统一1的个数有两种，一种是0x1慢慢&过去取，一种是用n&(n-1)消掉最后的1，如果n&(n-1)得到的值是0说明是2的次方。由于消掉最后的1,如果是2的次方就只有一个1.

2

如果是4的倍数也只有1个1，但是在是革一个位置，在奇数位置，如图所示

![image-20210618163512704](C:\Users\lisunyang\AppData\Roaming\Typora\typora-user-images\image-20210618163512704.png)

8的话长这样

![image-20210618163551721](C:\Users\lisunyang\AppData\Roaming\Typora\typora-user-images\image-20210618163551721.png)

```c++
class Solution {
public:
    bool isPowerOfFour(int n) 
    {
        if(n<0) return false;
        if(!(n&n-1)) // 可以判断是否只有1个1
        {
            while(n)
        {
            if((n&0x1)==1)
            {
                return true;
            }
            else
            {
                n>>=2;
            }
        }
        

        }
        return false;
        

        
        

    }
};
```

# 掩码

对应leetcode1001;

位掩码（BitMask），是”位（Bit）“和”掩码（Mask）“的组合词。”位“指代着二进制数据当中的二进制位，而”掩码“指的是一串用于与目标数据进行按位操作的二进制数字。组合起来，就是”用一串二进制数字（掩码）去操作另一串二进制数字“的意思

```c++
int maxProduct(vector<string>& words)
 {
unordered_map<int, int> hash;
int ans = 0;
for (const string & word : words) 
{
int mask = 0, size = word.size();
for (const char & c : word) {
    mask |= 1 << (c - 'a');  //这里其实是1左移，不是后面的左移注意下
    }
    //cout<<"mask="<<mask<<endl;
    cout<<"hash[mask]="<<hash[mask]<<" size="<<size<<endl;
    hash[mask] = max(hash[mask], size);//没看懂啊   有问题
    //cout<<"hash[mask]="<<hash[mask]<<" size="<<size<<endl;
    for (const auto& [h_mask, h_len]: hash) {
    if (!(mask & h_mask)) {
    ans = max(ans, size * h_len);
}
}
}
return ans;
}
```

```c++
vector<int> countingbits(int n)
{
    vector<int> dp(n+1,0);
    for(int i=1;i<n;++i)
    {
        if(dp[i-1]&1==1)
        {
             dp[i]=dp[i-1]+1;
        }
        else
        {
            dp[i]=dp[i>>1];
        }
       
    }
}
```

```
int findComplement(int num) 
    {
        int n=num;
        int count=0;
        for(int i=0;i<32;++i)
        {
            if((n&0x1)==1)
            {
               count= max(i,count);
            }
            n=n>>1;
        }
        // cout<<count<<endl;
        //  cout<<bitset<32>(num)<<endl;
        int res=0;
        for(int i=0;i<count;i++)
        {
            res=res+(((num&0x1)^1)<<i);
            num=num>>1;
        }
        cout<<res<<endl;
        return res;
        
        

    } //特别注意位元算事不能满足交换律的，还有位运算的优先级特别低，续要加括号。
    要对一个数的某些部分取反记得事用亦或，按位异或就好，亦或的位置是在后面的应^1
```

常见的位运算操作

![image-20210624110426963](C:\Users\lisunyang\AppData\Roaming\Typora\typora-user-images\image-20210624110426963.png)

```c++
void show2(int a,string str)
{
    cout<<str<<endl;
    cout<<bitset<32>(a)<<endl; 
}

void testBitwiseOperation(int a)
{
    //去掉最后一位
    show2(a,"初始值");
    a=a>>1;
    show2(a,"去掉最后一位");
    //在最后一位加个0
    a=a<<1;
    show2(a,"在最后一位加0");
    //在最后一位加个1
    a=(a<<1)+1;
    show2(a,"在最后一位加1");
    //把最后一位变成1
    a=a|1;
    show2(a,"把最后一位变成1");
    //把最后一位变成0
    a=(a|1)-1;
    show2(a,"把最后一位变成0");
    //最后一位取反
    a=a^1;
    show2(a,"把最后一位取反");
    //把右数第k位变成1
    int k=3;
    a=(a|(1<<(k-1)));      //取k-1的原因是最后1位是<<0
    show2(a,"把右数第k位变为1");
    //把右数第k位边位0
    a=(a&(~(1<<(k-1))));
    show2(a,"把右数第k位变为0");
    //右数第k位取反    //与1一伙就是取反，与0亦或保持不动
    a=(a^(1<<(k-1)));
    show2(a,"右数第k位取反");
    //取尾巴上的三位
    int b=a;
    b=b&7;
    show2(b,"取最后三位");
    //取右边第k位,这里的4也是2的（k-1）次方
    int c=(a&4)>>(k-1);
    int d=(a>>(k-1))&1;
    show2(c,"取右边的第k位");
    show2(d,"取右边的第k位"); 
}
```

总结：取多少都是& ，

把值变为1都是|，把值变为0是与&0

取反是与1抑或。