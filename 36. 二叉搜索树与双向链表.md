# [二叉搜索树与双向链表](https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&tqId=11179&tPage=2&rp=2&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

## 题目描述

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。



```java
/*
struct TreeNode {
	int val;
	struct TreeNode *left;
	struct TreeNode *right;
	TreeNode(int x) :
			val(x), left(NULL), right(NULL) {
	}
};*/
class Solution {
public:
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        if(pRootOfTree == nullptr)
            return nullptr;
        
        TreeNode* node = nullptr;
        Convert(pRootOfTree, node);
        
        while(node != nullptr && node->left != nullptr)
        {
            node = node->left;
        }
        
        return node;
    }
    /* 中序遍历，遍历到一个结点修改指向 */
    void Convert(TreeNode* pRootOfTree, TreeNode* &lastNodeInList)
    {
        if(pRootOfTree == nullptr)
            return;
        
        TreeNode* curNode= pRootOfTree;
        if(curNode->left != nullptr)
            Convert(curNode->left, lastNodeInList);
        
        curNode->left = lastNodeInList;
        if(lastNodeInList != nullptr)
            lastNodeInList->right = curNode;
        
        lastNodeInList = curNode;
        
        if(curNode->right != nullptr)
            Convert(curNode->right, lastNodeInList);
    }
};
```

```c++
//找到距离离最近的节点  下面是错误的，由于是二叉搜索树因此只要使用中序遍历就一定是有序的，不需要自己在根据二叉搜索树找到最近的那个节点

TreeNode *findLeftShort(TreeNode *pRootOfTree)
{
	TreeNode *node = pRootOfTree;
	if (pRootOfTree->left)
	{
		node = pRootOfTree->left;
		if (!node->right)
		{
			return node;
		}
		while (node)
		{
			node = node->right;
		}
		return node;
	}
	else
	{
		return nullptr;
	}
}

TreeNode *findRightShort(TreeNode *pRootOfTree)
{
	TreeNode *node = pRootOfTree;
	if (pRootOfTree->right)
	{
		node = pRootOfTree->right;
		if (!node->left)
		{
			return node;
		}
		while (node->left)
		{
			node = node->left;
		}
		return node;
	}
	else
	{
		return nullptr;
	}
}
void helperConvertCopy(TreeNode *pRootOfTree, TreeNode *node,TreeNode *front,TreeNode *tail)
{
	if (pRootOfTree == nullptr)
		return;
	helperConvertCopy(pRootOfTree->left, node,front,tail);
	TreeNode* left= findLeftShort(pRootOfTree);
	TreeNode* right=findRightShort(pRootOfTree);
	TreeNode *node=new TreeNode(pRootOfTree->val);
	TreeNode *nodeleft=new TreeNode(left->val);
	TreeNode *noderight=new TreeNode(right->val);
	node->left=nodeleft;
	node->right=noderight;
	nodeleft->left=front;
	nodeleft->right=node;
	noderight->right=tail;
	noderight->left=node;
	//to do
	helperConvertCopy(pRootOfTree->right, node,front,tail);
}
TreeNode *ConvertCopy(TreeNode *pRootOfTree)
{
	TreeNode *node;
	TreeNode* front;
	TreeNode* tail;
	front->left=nullptr;
	front->right=tail;
	tail->right=nullptr;
	tail->left=front;
	helperConvertCopy(pRootOfTree, node,front,tail);
	return front->right;
}

void test5()
{
	TreeNode* node= ConvertCopy(ToBinaryTree("4,2,5,1,3"));

}
```

```
//用来一个指针指向头部代表整个链表  嗨哟个两个指针一前以后互相指因为是双向的链表
class Solution {
public:
    Node* treeToDoublyList(Node* root) {
        if(root == nullptr) return nullptr;
        dfs(root);
        head->left = pre;
        pre->right = head;
        return head;
    }
private:
    Node *pre, *head;
    void dfs(Node* cur) {
        if(cur == nullptr) return;
        dfs(cur->left);
        if(pre != nullptr) pre->right = cur;
        else head = cur;
        cur->left = pre;
        pre = cur;
        dfs(cur->right);
    }
};

作者：jyd
链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/mian-shi-ti-36-er-cha-sou-suo-shu-yu-shuang-xian-5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

